(* Part of Fail-Safe C Compiler. (c) 2002-2004 Yutaka Oiwa. *)
(* * Auto-generated by ec (embedded-C). Do not edit. * *)

let bits_of_byte = 8

let sizeof_char = 1
let sizeof_short = 2
let sizeof_int = 4
let sizeof_long = 4
let sizeof_longlong = 8
let sizeof_float = 4
let sizeof_double = 8
let real_sizeof_longdouble = 8

let emit_downcoerce_longdouble = (* TODO: current limitation *)
  real_sizeof_longdouble > sizeof_longlong
let sizeof_longdouble = 
  if emit_downcoerce_longdouble then
    sizeof_double
  else
    real_sizeof_longdouble

let sizeof_pointer = 4

(* some architecture requires additional alignment (padding) to structs *)
let minimum_align_struct = 1

let max_bitfield_width = sizeof_int * bits_of_byte (* 32 *)

let char_is_signed = false
let is_littleendian = false

type quomod_style = 
    Div_round_to_zero | Mod_match_divisor | Mod_always_positive
let quomod_style = 
  match (1, 2), (-1, 2),
    (-1, -2), (1, -2) with
  (* 5/3     5/-3      -5/3      -5/-3 *)
    (1, 2), (-1, 2),  (-1, -2), (1, -2) -> Div_round_to_zero
  | (1, 2), (-2, -1), (-2, 1),  (1, -2) -> Mod_match_divisor
  | (1, 2), (-1, 2),  (-2, 1),  (2, 1) -> Mod_always_positive
  | _ -> failwith "FSC_CONFIG failed: unknown div/mod semantics"

let print_config () = 
  Printf.printf
    "Configuration values:

sizes:
   %d: char
   %d: short
   %d: int
   %d: long
   %d: long long
   %d: float
   %d: double
   %d: long double (real: %d)
   %d: pointers

char is %s.
endianness is %s-endian.
division semantics is \"%s\".
"
    sizeof_char sizeof_short sizeof_int sizeof_long sizeof_longlong
    sizeof_float sizeof_double sizeof_longdouble
    real_sizeof_longdouble
    sizeof_pointer
    (if char_is_signed then "signed" else "unsigned")
    (if is_littleendian then "little" else "big")
    (match quomod_style with 
      Div_round_to_zero -> "match with absolute value (normal)"
    | Mod_match_divisor -> "modulo sign matches divisor"
    | Mod_always_positive -> "modulo always positive")

let _ = begin (* TODO things *)
  assert (sizeof_longdouble = sizeof_double);
  assert (sizeof_int = sizeof_long);
  assert (sizeof_long = sizeof_pointer);
  assert (sizeof_int = sizeof_float);
  assert (sizeof_double = sizeof_longlong);
end

(* calculate_bitfields_packing *)
(* 入力: (サイズ (bit単位)) のリスト *)
(* 出力: (各要素の開始位置 (バイト位置とビット位置) のリスト と 全体のバイト幅, アライメント要求) の triple *)

let rec calculate_bitfields_packing rest_width words =
  function
      [] -> [], words * sizeof_int, sizeof_int
    | (width :: rest) as whole ->
	if width > max_bitfield_width then failwith "too wide bitfield"
	else if width <= rest_width then
	  let (r,final_bytes,final_align) 
	      = calculate_bitfields_packing (rest_width - width) words rest in
	  (((words - 1) * sizeof_int, rest_width - 1) :: r), final_bytes, final_align
	else
	  calculate_bitfields_packing (sizeof_int * bits_of_byte) (words + 1) whole

let calculate_bitfields_packing =
  calculate_bitfields_packing 0 0

let cpp_options = "-undef -D__sparc" (* not used *)

let allow_integer_arith_on_pointer = false

(* specification of runtime library behaviour *)

let use_hardware_null_check = true
let size_check_subsumes_cast_check = true
