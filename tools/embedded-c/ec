#!/usr/bin/perl
# -*- perl -*-
#
#   Part of Fail-Safe C Compiler. Produced by Yutaka Oiwa.
#   (c) 2001-2005 Yutaka Oiwa.
#   (c) 2005-     AIST.
#
#   This file is written by Yutaka Oiwa in 2006.
#
# $Id: ec 2065 2009-11-02 07:23:17Z yutaka $

use strict 'vars';
use FileHandle;
use Getopt::Long qw(:config bundling);
use File::Temp qw(tempdir);
use File::Basename;
use Pod::Usage;

# used for parser state and output
use constant SCRIPT => 0;
use constant PRINT => 1;
use constant PRINTF => 2;
use constant EMBEDDED_EC => 3;
use constant START => 4;
use constant FINISH => 5;
use constant TOPSCRIPT => 6;

our %internal_variables = 
  ( EC_VERSION_MSG => "* Auto-generated by ec (embedded-C). Do not edit. *" );
our %directives = 
  ( '' => 1,
    shared => 1,
    libs => 1,
    cflags => 1,
    onerror => 1,
  );

my $debug = 0;
my $keep_temp_dir = 0;
my $logfile = undef;
my $work_on_current = 0;
my $help = 0;
my $cc = 'gcc';
my $is_gcc = undef;
my @includes = ();
my @defvars = ();
my $outfile = undef;
my $header = undef;

GetOptions ('debug=i' => \$debug,
	    'work-on-current-dir' => \$work_on_current,
	    'keep-temp-dir' => \$keep_temp_dir,
	    'log-file|l=s' => \$logfile,
	    'cc=s' => \$cc,
	    'help|h' => \$help,
	    'I=s' => \@includes,
	    'D=s' => \@defvars,
	    'gcc' => \$is_gcc,
	    'o=s' => \$outfile,
	    'header=s' => \$header,
	    'no-gcc' => sub { $is_gcc = 0; },
	   ) or pod2usage (2);
pod2usage(1) if ($help);

if (!defined $is_gcc) {
    my $t = `echo + __GNUC__ + | $cc -E -`;
    $is_gcc = ($t =~ /\+\s*\d+\s*\+/);
}

my $fname = $ARGV[0];
$fname = '<stdin>' unless defined $fname;

my $basedir = dirname($fname);

if (! (grep { $_ eq '-' } @includes)) {
    unshift @includes, ($basedir, '-') if $is_gcc;
}

my $includes = join (' ', map { "-I" . &shellescape($_) } @includes);
my $defvars = join (' ', map { "-D" . &shellescape($_) } @defvars);

if ($logfile) {
    open LOG, "> $logfile\0" or die "$logfile: $!";
    $debug ||= 1;
} else {
    open LOG, ">&STDERR";
}

undef $/; #### read whole file contents at once!

my $input = <>;

my @input = split(/(\<%\]\]|\<%=(?:\S*(?:[ \t]|(?=\n)))?|\<%#\w*[ \t]*|\<%|\[\[\??%\>|#%\>|%\>)/, $input);

use vars qw(@parsed $script_count $workdir @result_cache);

$script_count = 0;

my ($parsed_id, $line) = parse_script(\@input, 0, 1);

die "$fname:$line: Parse error: Unexpected token \"$input[0]\"" unless scalar @input == 0;

$workdir = setup_tempdir();

my $s = run_script($parsed_id);
		    
if (defined $header) {
    $header = $internal_variables{$header} if defined $internal_variables{$header};
    $s = $header . "\n" . $s;
}

if (defined $outfile) {
    open (O, ">", $outfile) or die "cannot open output $outfile: $!\n";
    print O $s or die "cannot write to output $outfile: $!\n";
    close O or die "error closing output $outfile: $!\n";
} else {
    print $s;
}

exit 0;

# transition table
#  START: top of script
#    <%#     TOPSCRIPT
#    <%      [emit START] SCRIPT
#    <%=     [emit START] PRINTF
#    %>      ERROR
#    #%>      ERROR
#    [[%>    ERROR
#    <%]]    ERROR
#    TEXT    [emit START] [output as PRINT] PRINT

#  TOPSCRIPT: inside <%# script
#    <%#     ERROR
#    <%      ERROR
#    <%=     ERROR
#    %>      ERROR
#    #%>     [eat \n] TOPSCRIPT
#    [[%>    ERROR
#    <%]]    ERROR
#    TEXT    [output as SCRIPT] TOPSCRIPT

#  PRINT: body of ec script
#    <%#     ERROR
#    <%      SCRIPT
#    <%=     [output printf as SCRIPT] PRINTF
#    %>      ERROR
#    #%>     ERROR
#    [[%>    ERROR
#    <%]]    ERROR
#    TEXT    [output as PRINT] PRINT

#  SCRIPT: inside <%
#    <%#     ERROR
#    <%      ERROR
#    <%=     ERROR
#    %>      PRINT
#    #%>     ERROR
#    [[%>    [parse complete EC script, output as EMBEDDED_EC][eat "<%]]"] SCRIPT
#    <%]]    ERROR
#    TEXT    [output as SCRIPT] SCRIPT

#  PRINTF: inside <%=
#    <%#     ERROR
#    <%      ERROR
#    <%=     ERROR
#    %>      [output closing as SCRIPT] PRINT
#    #%>     ERROR
#    [[%>    ERROR
#    <%]]    ERROR
#    TEXT    [output as SCRIPT] PRINTF

sub parse_error {
    die "\001$_[0]\002";
}

sub parse_script (\@$$) {
    my ($script_id) = $script_count++;
    my ($input, $error_ok, $start_line) = @_;
    my @output = ();
    my $mode = START;
    my $submode = undef;
    my $substartline = -1;
    my $line = $start_line;

    my @rval = eval {
	while (defined ($_ = shift @$input)) {
	    print LOG "token: M$mode, L$line, \"$_\"\n" if $debug >= 3;
	    if ($_ eq '<%]]') {
		unshift @$input, $_;
		last;
	    } elsif ($_ =~ /^<\%\#(\w*)[ \t]*$/) {
		parse_error("cannot use <\%\# except in script top") unless $mode == START;
		parse_error("unknown directive <%#$1 #%>") unless defined $directives{$1};
		$mode = TOPSCRIPT;
		$submode = $1;
		$substartline = $line;
		next;
	    } elsif ($_ eq '<%') {
		if ($mode == START) {
		    push @output, [START];
		    $mode = SCRIPT;
		    next;
		} elsif ($mode == PRINT) {
		    $mode = SCRIPT;
		    next;
		} else { 
		    parse_error();
		}
	    } elsif ($_ =~ /^\<\%=(\S*)\s*$/) {
		if ($mode == START) {
		    push @output, [START];
		    $mode = PRINT;
		    # FALLTHROUGH
		}
		parse_error() unless ($mode == PRINT);
		my $format = $1 || parse_error("no format given");
		push @output, [SCRIPT, "printf (\"\%$format\", ("];
		$mode = PRINTF;
		next;
	    } elsif ($_ eq '%>') {
		if ($mode == SCRIPT) {
		    $mode = PRINT;
		    next;
		} elsif ($mode == PRINTF) {
		    push @output, [SCRIPT, "));"];
		    $mode = PRINT;
		    next;
		} else {
		    parse_error();
		}
	    } elsif ($_ eq '#%>') {
		if ($mode == TOPSCRIPT) {
		    if (substr($input->[0], 0, 1) eq "\n") {
			print LOG "consumed \\n after #%> at line $line\n" if $debug >= 2;
			push @output, [ SCRIPT, "\n" ];
			$line++;
			my $l = substr($input->[0], 1);
			if ($l eq '') {
			    shift @$input;
			} else {
			    $input->[0] = $l;
			}
		    }
		    $mode = START;
		    next;
		} else {
		    parse_error();
		}
	    } elsif ($_ =~ /^\[\[(\??)\%\>$/) {
		parse_error() unless $mode == SCRIPT;
		my $eok = $1 eq '?';
		my ($sid);
		($sid, $line) = parse_script($input, $eok, $line);
		print LOG "embedded: SID=$sid, endline = $line\n" if $debug >= 2;
		parse_error() unless shift @$input eq '<%]]';
		push @output, [ EMBEDDED_EC, $sid, $eok, $line ];
		$mode = SCRIPT;
		next;
	    } else {
		if ($mode == START) {
		    next if $_ eq '';
		    if ($_ eq "\n" && $input->[0] eq '<%#') {
			push @output, [ SCRIPT, $_ ];
		    } else {
			push @output, [ START ];
			push @output, [ PRINT, $_ ];
			$mode = PRINT;
		    }
		} elsif ($mode == TOPSCRIPT) {
		    push @output, [ TOPSCRIPT, $submode, $substartline, $_ ];
		} elsif ($mode == SCRIPT || $mode == PRINTF) {
		    push @output, [ SCRIPT, $_ ];
		} elsif ($mode == PRINT) {
		    push @output, [ PRINT, $_ ];
		} else {
		    die "panic"
		}
		$line += (s/\n/\n/g);
	    }
	}
	if ($mode == START) {
	    push @output, [ START ], [ FINISH ];
	} elsif ($mode == PRINT) {
	    push @output, [ FINISH ];
	} else {
	    parse_error "premature end of script";
	}
	$parsed[$script_id] = [ $error_ok, \@output, $start_line ];
	print LOG "parse done: $script_id : ends at L$line\n" if $debug >= 2;
	return ($script_id, $line);
    };
    if ($@) {
	if ($@ =~ /^\001(.*)\002(.*)$/) {
	    if ($1 eq '') {
		die "$fname:$line: Parse Error: Unexpected token \"$_\"\n"
	    } else {
		die "$fname:$line: Parse Error: $1 at token \"$_\"\n"
	    }
	} else {
	    die $@;
	}
    }
    @rval;
}

sub setup_tempdir {
    return "." if $work_on_current;
    undef $ENV{TMPDIR} if $ENV{TMPDIR} =~ /^-/;
    # gcc broken in this weired case...
    # # very paranoid, but I just found...
    my $workdir = tempdir( CLEANUP => !$keep_temp_dir );
    $SIG{INT} = sub { die "Interupted.\n" }; # to clean-up temporary directory
    print LOG "workdir is $workdir\n" if $keep_temp_dir;
    $workdir;
}

sub escape_C_string {
    my ($s, $cr_preserve) = @_;
    printf LOG "escape_stirng: >>$s<<\n" if $debug >= 9;
    $s =~ s/\\/\\\\/g;
    $s =~ s/\"/\\\"/g;
    $s =~ s/([\000-\011\013-\037\177-\377])/sprintf ("\\%03o",ord $1)/ge;
    if ($cr_preserve) {
	$s =~ s/\n/\\n\"\n    \"/g;
    } else {
	$s =~ s/\n/\\n/g;
    }
    return $s;
}

sub shellescape {
    local ($_) = @_;
    return $_ if /^[A-Za-z0-9.\-_\/]+$/; # safe arguments
    s/\\/\\\\/g;
    s/'/'\\''/g;
    return "'$_'";
}

sub escape_Unix_filename {
    local ($_) = @_;
    $_ = "./$_" if /^-/;
    return $_ if /^[A-Za-z0-9.\-_\/]+$/; # safe filenames
    s/\\/\\\\/g;
    s/'/'\\''/g;
    return "'$_'";
}

sub run_script {
    my ($id, $shared_header, $cflags, $libs) = @_;

    my $rcache = $result_cache[$id];
    if (defined $rcache) {
	if (@$rcache == 0) {
	    die "panic: script $id evaluation recurses. why?";
	}
	return @$rcache->[0];
    } else {
	$result_cache[$id] = [];
    }

    my $parsed_ref = $parsed[$id];
    my ($error_ok, $script, $start_line) = @$parsed_ref;
    my $onerror = undef;

    my $sname = "$workdir/ec_work_$id";

    my $S = new FileHandle "> $sname.c" or die "$sname.c: $!";

    print LOG "\n==== building script $id (starting at line $start_line) to $sname.c\n" if $debug;

    print $S "#include <stdio.h>\n#define EC_VERSION_MSG \"$internal_variables{EC_VERSION_MSG}\"\n#line 1 \"$fname\"\n$shared_header#line $start_line\n";
    foreach my $a (@$script) {
	print LOG "parsed: [", (join ', ', @$a), "]\n" if $debug >= 3;
	my $type = $a->[0];
	if ($type == TOPSCRIPT) {
	    my ($subtype, $line) = ($a->[1], $a->[2]);
	    if ($subtype eq '') {
		print $S $a->[3];
	    } elsif ($subtype eq 'shared') {
		print $S $a->[3];
		$shared_header .= "#line $line\n$a->[3]\n";
	    } else {
		my $crs = ($a->[3] =~ tr/\n//);
		print $S ("\n" x $crs);
		if ($subtype eq 'libs') {
		    $libs .= " $a->[3]";
		} elsif ($subtype eq 'cflags') {
		    $cflags .= " $a->[3]";
		} elsif ($subtype eq 'onerror') {
		    $onerror = $a->[3];
		} else {
		    die "unknown subtype $subtype at line $line";
		}
	    }
	} elsif ($type == SCRIPT) {
	    print $S $a->[1];
	} elsif ($type == PRINT) {
	    printf $S " fwrite(\"%s\", 1, %d, stdout);",
	      escape_C_string($a->[1], 1),
		length $a->[1];
	} elsif ($type == EMBEDDED_EC) {
	    my $eid = $a->[1];
	    my $error_ok = $a->[2];
	    my $result = run_script($eid, $shared_header, $cflags, $libs);
	    if ($error_ok) {
		if (defined $result) {
		    printf $S "(fputs(\"%s\", stdout), 1)", escape_C_string($result);
		} else {
		    printf $S "0";
		}
	    } else {
		printf $S "fputs(\"%s\", stdout);", escape_C_string($result);
	    }
	    print $S "\n#line $a->[3]\n";
	} elsif ($type == START) {
	    print $S " int main(void) { ";
	} elsif ($type == FINISH) {
	    print $S "return 0; }\n";
	} else {
	    die "panic";
	}
    }
    print LOG "---- script $id generation finished.\n" if $debug;
    close $S or die "$!";

    $error_ok = 1 if defined $onerror;

    my $exename = escape_Unix_filename "$sname.exe";
    my $srcname = escape_Unix_filename "$sname.c";

    print LOG "---- compiling $sname.exe\n" if $debug;
    $cflags =~ s/\n/ /g;
    $libs =~ s/\n/ /g;
    my $cmdline = "$cc $includes $cflags $defvars -o $exename $srcname$libs";
    print LOG "+ $cmdline\n" if $debug;
    open COMPILER, "-|", "$cmdline 2>&1" or die "invocation to $cc failed.";
    my $compiler_output = <COMPILER>;
    print LOG $compiler_output if $debug;
    unless (close COMPILER and $? == 0) {
	$result_cache[$id] = [$onerror];
	print LOG "---- compilation to $sname.exe failed\n" if $debug;
	if ($error_ok) {
	    print LOG "==== done processiong script $id.\n\n" if $debug;
	    return $onerror;
	}
	print STDERR $compiler_output if ($logfile || !$debug);
	die "Script ($id) does not compile.\n";
    }
    print LOG "---- running $sname.exe\n" if $debug;
    open(O, "$exename |") or die "executing $sname.exe: $!";
    my $result = <O>;
    unless (close O and $? == 0) {
	 if ($error_ok) {
	     $result = $onerror;
	 } else {
	     die "Script ($id) returned failure status.\n";
	 }
    }
    print LOG "==== done processiong script $id.\n\n" if $debug;
    $result_cache[$id] = [$result];
    return $result;
}
__END__

=head1 NAME

ec - embedded C processor

=head1 SYNOPSIS

ec [options] [file ...]

  Options:
    -l file                Write process log to file
    --keep-temp-dir        Keep contents of temporary directory after use
    --work-on-current-dir  Generate all temporary files in current directory
    --debug=n              Set debug level (default=1 if -l given, 0 otherwise)
    --cc compiler          Set name of the C compiler to use
    -D symbol              Declare preprocessor symbols
    -o file                Specify the output file
    -h, --help             Show this message

=cut
