/* -*- C -*- */
/* 
   Part of Fail-Safe C Runtime. Produced by Yutaka Oiwa.
   (c) 2001-2005 Yutaka Oiwa.
   (c) 2005-2009 AIST.

   This file is written by Yutaka Oiwa in 2006-2009.

   This file is distributed under Apache License 2.0 with a special exception.
   See the file LICENSE contained in the distribution.
*/
/**
  * @file stdlib/signal.c
 */

%% C-PROLOGUE

#include <signal.h>

#include <sys/utsname.h>
#include <string.h>

%% FSC-PROLOGUE

#include <signal.h>

%% REQUIRED-DECLS

require_function sigaction;
auto_generate raise;
auto_generate kill;
require_function sigprocmask;

%% NATIVE-IMPLEMENTATION

#ifndef FSC_USE_INLINE_NULLCHECK
#include <nullptr_handler.h>
#endif
#include <assert.h>
#include <fsc_mman.h>

static ptrvalue fsc_signal_handlers[_NSIG];
static int fsc_signal_use_sigaction[_NSIG];

/* TODO:

   The following things are not implemented correctly:

   (1) handling of SIG_IGN for SIGSEGV (user-generated signal only)
   (2) handling of NULL-pointer access inside user-generated SIGSEGV handler.
   (3) blocking of SIGSEGV | SIGBUS.

      For (1), it acts as if it were SIG_DFL.
      for (2) and (3), null-pointer access cannot be trapped by internal FSC handler,
      and SIGSEGV will be directly handled by the kernel instead.
      (so, unwanted "Segmentation Fault" message will appear.)
   
      To resolve this, we must implement a queue for internally-blocked signals,
      and make sure SIGSEGV/SIGBUS is not blocked at any time.

   (4) many siginfo fields.

      Easier than above.
*/

void fsc_signal_handler(int sig, siginfo_t *info, void *p) {
  base_t fscinfo_b;
  ptrvalue handler, pv;
  struct struct_Sn16stdlib_siginfo_t_ *fscinfo;
  value *varg;

  pv = ptrvalue_of_base_ofs(0, 0);

  assert(0 < sig && sig < _NSIG);
#ifdef FSC_DEBUG_RUNTIME
  if (fsc_debug_flag['S']) 
    fprintf (stderr, "signal %d caught by fsc_signal_handler.\n", sig);
#endif

  if (sig == SIGBUS || sig == SIGSEGV) {
    /* SIGBUS and SIGSEGV are only passed to user-defined handler
       if it is intentionally-generated by kill(2). */
    if (info->si_code != SI_USER 
#ifdef SI_TKILL
	&& info->si_code != SI_TKILL /* broken Linux generates this for raise(3)! */
#endif
	) {
	pv = realaddr_to_mapped_fat_pointer(info->si_addr);
	if (base_of_ptrvalue(pv) == 0) {

#ifndef FSC_USE_INLINE_NULLCHECK
	    fsc_nullptr_handler(sig, info, p);
#else
	    fprintf (stderr, "PANIC: signal %d generated by kernel!", sig);
#endif
	    fsc_halt_program();
	}
    }
#ifndef FSC_USE_INLINE_NULLCHECK
    struct sigaction sa;
    sigaction(sig, NULL, &sa);
    if (sa.sa_sigaction != fsc_nullptr_handler &&
	sa.sa_sigaction != fsc_signal_handler) {
	sa.sa_sigaction = fsc_nullptr_handler;
	sa.sa_flags |= SA_SIGINFO;
#ifdef FSC_DEBUG_RUNTIME
	if (fsc_debug_flag['S']) 
	  fprintf (stderr, "re-enabling FSC custom signal handler for signal %d here.\n", sig);
#endif
	sigaction(sig, &sa, NULL);
#endif
    }
  }

  handler = fsc_signal_handlers[sig];

  fscinfo_b = fsc_alloc_block_library(&fsc_typeinfo_Sn16stdlib_siginfo_t_.val, 1);
  fscinfo = (struct struct_Sn16stdlib_siginfo_t_ *)fscinfo_b;
  fscinfo->fld_si_signo.cv = value_of_int(info->si_signo);
  fscinfo->fld_si_errno.cv = value_of_int(info->si_errno);
  fscinfo->fld_si_code.cv = value_of_int(info->si_code);

  varg = (value *)fsc_alloc_varargs(3);
  varg[0] = value_of_int(sig);
  varg[1] = value_of_base_ofs(fscinfo_b, 0);
  varg[2] = value_of_ptrvalue(pv);

#ifdef FSC_DEBUG_RUNTIME
  if (fsc_debug_flag['S']) 
    fprintf (stderr, "invoking handler @ %x.\n", base_of_ptrvalue(handler));
#endif

  fsc_invoke_func_with_varargs(0,
			       base_of_ptrvalue(handler), ofs_of_ptrvalue(handler),
			       (base_t)varg, 0);

#ifdef FSC_DEBUG_RUNTIME
  if (fsc_debug_flag['S']) 
    fprintf (stderr, "returned from handler @ %x.\n", base_of_ptrvalue(handler));
#endif

  fsc_dealloc_internal((base_t)varg, "fsc_signal_handler");
  fsc_dealloc_internal(fscinfo_b, "fsc_signal_handler");
}

static inline ptrvalue ptrvalue_of_value(value v) {
  return ptrvalue_of_base_ofs(base_of_value(v), ofs_of_value(v));
}

static void make_real_samask(sigset_t *r, base_t b, ofs_t o) {
  int i;

  sigemptyset(r);
  for (i = 0; i < _NSIG; i++) {
    if (read_byte(b, o + i))
      sigaddset(r, i);
  }
}

static void make_fsc_samask(sigset_t *r, base_t b, ofs_t o) {
  int i;

  for (i = 0; i < _NSIG; i++) {
    write_byte(b, o + i, (sigismember(r, i) ? 1 : 0), NULL);
  }
}

/**
 * @fn int sigaction(int sig, const struct sigaction *new, struct sigaction *old)
 * @author Yutaka Oiwa.
 */
value FS_FiPSn16stdlib_sigaction_PSn16stdlib_sigaction__i_sigaction
  (base_t sig_b, unsigned int sig, base_t new_b, ofs_t new_o, base_t old_b, ofs_t old_o) {
  /* prepare new struct */
  struct sigaction new_dat, *new, old_dat;
  int retval;
  ptrvalue old_handler;
  int old_use_sigaction;

  /* sig is currently unsigned */
  if (sig < 0 || _NSIG <= sig)
    fsc_raise_error_library(sig_b, ofs_of_base_vaddr(sig_b, sig), ERR_INVALIDARGS, "sigaction: bad value passed as sig");

  old_handler = fsc_signal_handlers[sig];
  old_use_sigaction = fsc_signal_use_sigaction[sig];

  if (base_remove_castflag(new_b) != 0) {
    ptrvalue fsc_sa_handler = ptrvalue_of_value(read_word(new_b, new_o));
    ptrvalue fsc_sa_sigaction = ptrvalue_of_value(read_word(new_b, new_o + 4));
    value sa_flags_f = read_word(new_b, new_o + 8);
    int sa_flags = vaddr_of_value(sa_flags_f);

    int use_sa = sa_flags & SA_SIGINFO;
    ptrvalue handler = use_sa ? fsc_sa_sigaction : fsc_sa_handler;
    base_t handler_b = base_of_ptrvalue(handler);
    ofs_t handler_o = ofs_of_ptrvalue(handler);
    
    void *real_handler;

    if (base_remove_castflag(handler_b) == 0) {
      if (handler_o != (ofs_t)SIG_DFL && handler_o != (ofs_t)SIG_IGN)
	fsc_raise_error_library(handler_b, handler_o, ERR_INVALIDARGS, "sigaction: bad value passed as handler");
      real_handler = (void *)handler_o;

      if (sig == SIGSEGV || sig == SIGBUS) {
	real_handler = 
#ifndef FSC_USE_INLINE_NULLCHECK
	SIG_IGN
#else
	fsc_nullptr_handler
#endif
	; /* fsc does not allow overriding default handlers for those signals. */
      }
    } else {
      if (ofs_of_ptrvalue(handler) != 0)
	fsc_raise_error_library(handler_b, handler_o, ERR_OUTOFBOUNDS, "sigaction: bad pointer passed as handler");
      if (get_header(handler_b)->tinfo->kind != TI_FUNCTION)
	fsc_raise_error_library(handler_b, handler_o, ERR_OUTOFBOUNDS, "sigaction: non-function pointer passed as handler");
      fsc_signal_handlers[sig] = handler;
      fsc_signal_use_sigaction[sig] = use_sa;
      real_handler = (void *)fsc_signal_handler;
      fsc_enable_signal_mutex();
      sa_flags |= SA_SIGINFO;
    }
    new_dat.sa_handler = real_handler;
    new_dat.sa_sigaction = real_handler;
    new_dat.sa_flags = sa_flags;
    make_real_samask(&new_dat.sa_mask, new_b, new_o + 12);
    new = &new_dat;
  } else {
    new = NULL;
  }

  retval = sigaction(sig, new, &old_dat);

  if (base_remove_castflag(old_b) != 0) {
    ptrvalue handler_pv;
    void *handler = ((old_dat.sa_flags & SA_SIGINFO) ? (void *)old_dat.sa_handler : (void *)old_dat.sa_sigaction);
    if (handler == SIG_DFL || handler == SIG_IGN) {
      handler_pv = ptrvalue_of_base_ofs(0, (ofs_t)handler);
    } else if (handler == (void *)fsc_signal_handler) {
      handler_pv = old_handler;
      old_dat.sa_flags = ((old_dat.sa_flags & ~SA_SIGINFO)
			  | (old_use_sigaction ? SA_SIGINFO : 0));
    } else {
      handler_pv = ptrvalue_of_base_ofs(0, (ofs_t)SIG_DFL);
    }
    write_word(old_b, old_o, value_of_ptrvalue(handler_pv), &fsc_typeinfo_Sn16stdlib_sigaction_.val);
    write_word(old_b, old_o + 4, value_of_ptrvalue(handler_pv), NULL);
    write_word(old_b, old_o + 8, value_of_int(old_dat.sa_flags), NULL);
    make_fsc_samask(&old_dat.sa_mask, old_b, old_o + 12);
  }
  return value_of_int(retval);
}

/**
 * @fn int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
 * @author Yutaka Oiwa.
 */
value FS_FiPSn15stdlib_sigset_t_PSn15stdlib_sigset_t__i_sigprocmask(base_t how_b, unsigned int how, base_t set_b0, ofs_t set_o, base_t oldset_b, ofs_t oldset_o) {
    sigset_t set, oset;
    int ret;
    base_t set_b = base_remove_castflag(set_b0);

    if (set_b == 0) {
        if (set_o != 0)
            fsc_raise_error_library(set_b, set_o, ERR_INVALIDARGS, "sigprocmask: invalid mask");
    } else {
        if (how != SIG_BLOCK && how != SIG_UNBLOCK && how != SIG_SETMASK)
            fsc_raise_error_library(how_b, ofs_of_base_vaddr(how_b, how), ERR_INVALIDARGS, "sigprocmask: invalid \"how\" argument");
        sigemptyset(&set);
        make_real_samask(&set, set_b, set_o);
    }
    ret = sigprocmask(how, (set_b == 0 ? NULL : &set), &oset);

    if (base_remove_castflag(oldset_b) == 0) {
	if (oldset_o != 0)
	    fsc_raise_error_library(oldset_b, oldset_o, ERR_INVALIDARGS, "sigprocmask: invalid old mask");
    } else {
	make_fsc_samask(&oset, oldset_b, oldset_o);
    }
    return value_of_int(ret);
}
